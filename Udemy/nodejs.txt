==========================================================Node.js==========================================================

Sections Covered:
-----------------
Section: 1
Section: 2
Section: 3
Section: 4
Section: 5
Section: 9
Section: 12
Section: 13
Section: 21
Section: 22
Section: 24
Section: 25
Section: 26

---------------------------------------------------------Section-1--------------------------------------------------------

# Node.js is a very powerful JavaScript-based platform built on Google Chrome's JavaScript V8 Engine

# node.js is javascript runtime

# google chrome JS v8 is just a compiler use to compile javascript code.

# v8 itself had been writen in c++

# It is used to develop I/O intensive web applications like video streaming sites, single-page applications, and other web applications.

# Node.js is a server-side platform

# node.js easily building fast and scalable network applications

# node.js uses:
	- event-driven
	- non-blocking I/O model
* where this make it:
	- lightweight
	- efficient
	- perfect for data-intensive real-time applications that run across distributed devices.

# Node.js = Runtime Environment + JavaScript Library

# Terms:
	- application: computer program running on single host (machine)
	- network application: it's an application running on one host and provides a communication to another application running on different host like front end and back end apps.
	- real-time applications: A real-time application (RTA) is a one that functions within a time frame that the user senses as immediate or very close to it, like aircraft navigation applications (program)
	- event-driven: which is a computer program that is written to respond to actions generated by the user or the system.
	- non-blocking I/O model: allowing a single process to serve multiple requests at the same time
	- data-intensive: is a class of parallel computing applications which use a data parallel approach to process large volumes of data typically terabytes or petabytes in size and typically referred to as big data.


# node.js features:
	- all APIs of node.js are asynchronous which mean non-blocking and event driven.
	- event driven
	- very fast where it's built on google chrome's V8
	- single thread, high scalable, because it's come with event looping.
	- no buffering, node.js never buffer any data, output the data in chunks.

# Where to Use Node.js?

	- slow I/O bound Applications    ---> word processing systems, web applications, copying files, and downloading files
	- Data Streaming Applications
	- Data Intensive Real-time Applications (DIRT)  ---> marketing analytics, image processing, machine learning, and web crawling
* web crawling is a computer program that automatically and systematically searches web pages for certain keywords
	- JSON APIs based Applications
	- Single Page Applications: ---> Gmail, Google Maps, AirBNB, Netflix, Pinterest, Paypal,

# Where Not to Use Node.js?
	- It is not advisable to use Node.js for CPU intensive applications. CPU bound ---> encoding video, moive maker.

# explain what's the meaning of non-blocking I/O model

	- imagine we have resturant
	- there's one waiter to serve 2 tabels
	- of course there's some waiting time on each table to select food, get some drinks, talking and then get the food
	- now look to the model below

	waiter ∆ this symbole mean the waither will serve here and it's single thread technique.

	table1 --> ::::----:::-----::::::--:::--:::
				∆       ∆         ∆     ∆    ∆
	table2 --> ----::::---:::::------::-----:::
					∆      ∆         ∆      here there will be waiting longer till the waiter done with first table.

	in another hand
	I/O: inactive time --> like reading from fielsystem, making network requests waiting for time to pass
	 				  |      |         |    |
	Request --> ::::----:::-----::::::--:::--:::
	 			∆ 		 ∆         ∆     ∆    ∆
	  CPU: active attention / time

	* so from the above:
		1. a request can be divided into CPU work and I/O work, work in another word is bound.
		2. servers handle requests using threads, which each independently requests.
		3. nonblocking I/O allows a thread to suspend a request while it's perfroming IO to work on a different request.
		4. nonblocking I/O allows node.js to efficintly handle IO-heavy workloads with only one thread.

# A Node.js application consists of the following three important components −

	1. Import required modules − We use the 'require' keyword to load Node.js modules.

	2. Create server − A server which will listen to client's requests similar to Apache HTTP Server.

	3. Read request and return response − The server created in an earlier step will read the HTTP request made by the client which can be a browser or a console and return the response.  

	- import vs require keyword:
	  ------------------------- 
		i. In NodeJS, require() is a built-in function to include external modules that exist in separate files. require() statement basically reads a JavaScript file, executes it, and then proceeds to return the 'export' object. require() statement not only allows to add built-in core NodeJS modules but also community-based and local/user modules.

		ii. import() & export() statements are used to refer to an ES module (ECMAScript). Other modules with file types such as .json cannot be imported with these statements. They are permitted to be used only in ES modules and the specifier of this statement can either be a URL-style relative path or a package name. Also, the import statement cannot be used in embedded scripts unless such script has a type="module". A dynamic import can be used for scripts whose type is not “module”

		- ES modules: As of ES6 (ES2015), JavaScript supports a native module format called ES Modules, or ECMAScript Modules. This is modern way to do modules in JavaScript. This approach uses the 'export' and 'import' keywords, instead of the older CommonJS syntax of module. 'exports' and 'require'.


# REPL stands for Read Eval Print Loop:
	1. Read − Reads user's input, parses the input into JavaScript data-structure, and stores in memory.
	2. Eval − Takes and evaluates the data structure.
	3. Print − Prints the result.
	4. Loop − Loops the above command until the user presses ctrl-c twice.

	- to start REPL --> $ node 	<-- interactive mode

	_ using underscore return the last result

	- some important command using with repl:
		(.help) 			− list of all commands.
		(.break) 			− exit from multiline expression.
		(.clear) 			− exit from multiline expression.
		(.save <filename>) 	− save the current Node REPL session to a file.
		(.load <filename>) 	− load file content in current Node REPL session.


# Node Package Manager (NPM): 
  ---------------------------
  
 * provides two main functionalities:

	− Online repositories for node.js packages/modules which are searchable on search.nodejs.org
	- Command line utility to install Node.js packages, do version management and dependency management of Node.js packages.

	* to check npm version:
		> npm --version
	
	* to update npm:
		> sudo npm install npm -g

	* to install any module using npm
		> npm install <module name>

		ex: to install node.js web framework known as express.
		> npm install express

	* local mode installation: using npm install <name>  will create directory called <node_modules> in the same working directory | can be imported using require(). | > npm ls
	
	* global mode installation: using npm install <name> -g and store the installed package in the system directory. | npm ls -g

	* to uninstall any package use:
		> npm uninstall <name>

	* to update any package use:
		> npm update <name>

	* to search for any package use:
		> npm search <name>

	* create module --> later and not for now.


---------------------------------------------------------Section-2--------------------------------------------------------

# take a look on the code lines below this will cover most of the JavaScript syntax.

	- to use comment in JavaScript we can use 
		i. // for single line
		ii. /* */ for multiple line
	
	- below is a complete program had been written in the JavaScript to illustrate how to use syntax
	/*
	var z = 1, y = 2, x = 3;
	var a, b
	var c = 30

	a = 10
	b = 20

	//--------------------
	console.log("a = ", a)
	console.log("b = ", b)
	console.log("c = ", c)

	console.log("a + b = ",a + b)
	console.log("a - b = ", a - b)
	console.log("a * b = ", a * b)
	console.log("a % b = ", a % b) // the modulus 
	console.log("a / b = ", a / b)
	console.log("a before ++ = and a after ++ =", a ++, a)
	console.log("a before -- =  and a after -- = ", a --, a)
	// in the code line below there's very important issue need to take care of is when using + with string and number
	console.log("special case of concatenation letter z with a value = ", "z"+a)
	//--------------------
	console.log("a == b => ", a == b)
	console.log("a != b => ", a != b)
	console.log("a > b => ", a > b)
	console.log("a < b => ", a < b)
	console.log("a >= b => ", a >= b)
	console.log("a <= b => ", a <= b)
	//--------------------
	y = true
	z = false
	console.log("y && z => ", y && z)
	console.log("y || z => ", y || z)
	console.log("!(y && z) => ", !(y && z))
	//----------------------
	w = 2
	x = 3
	y = ~x
	z = -12
	omega = 12
	// This function is used to convert any dec. to binary and print it as string.
	function dec2bin(dec){
	  return (dec >>> 0).toString(2);
	}
	console.log("w = 2 = " , dec2bin(2))
	console.log("x = 3 = " , dec2bin(3))
	console.log("w & x => ", w & x)
	console.log("w | x => ", w | x)
	console.log("w ^ x => ", w ^ x)
	console.log("~x => ",  ~x, dec2bin(y))
	console.log("w << 1 => ", w << 1)   // left shift 
	console.log("w >> 1 => ", w >> 1)   // right shift
	console.log("w >>> 1 => ", w >>> 1) // right shift with zero
	console.log("omega: " + dec2bin(omega))
	console.log("z: " + dec2bin(z))
	//-----------------------
	d = (a > b) ? a : c
	console.log(d)
	//-----------------------
	if (a > b) {
	  console.log("a > b")
	}else if (a < b){
	  console.log("a < b")
	}else{
	  console.log("unable to determine")
	}
	//-----------------------
	e = 5
	switch (e) {
	  case 1:
	  console.log("1")
	  break
	  case 2:
	  console.log("2")
	  break
	  case 3:
	  console.log("3")
	  break
	  case 4:
	  console.log("4")
	  break
	  case 5:
	  console.log("5")
	  break
	  default: console.log("Default")
	}
	//-----------------------
	f = 0
	while(f < 5){
	  console.log(f)
	  f += 1
	}
	//-----------------------
	g = 5
	do {
	  console.log(g)
	}while (g < 5)
	//-----------------------
	for(h = 101; h <= 102; h++){
	  console.log(h)
	}

	//-----------------------
	j = 0
	while(j < 8){

	  if(j == 4){
	    console.log("we reach to #4 so we will use continue...")
	    j += 1  //it's to important to increase counter here or we will fall into infinty loop
	    continue;
	  }
	  if(j == 7){
	    console.log("we reach to #7")
	  }
	  console.log(j)
	  j += 1
	}
	//-----------------------
	console.log("Using labels") // it used with break and continue and must be prefix for a block of code 
	outerloop:
	for(k = 0; k <= 3; k++){
	  console.log(k)
	  innerloop:
	  for(l = 10; l <= 15; l++){
	    if(l == 14) break;
	    if(l == 13) break innerloop
	    //if(l == 12) break outerloop
	    console.log(l)
	  }
	}
	//-----------------------
	function myfunc(m){
	  console.log("Hello ", m)
	}
	myfunc("Mustafa")


	//-----------------------

	# to create object in javascript
	<var_type> <var_name> = {};

	
	const person = {
		name : 'Max',
		age : 29,
		greet : () => {
		console.log('Hi, I am ' + this.name)
		}
	};

	console.log(person);
	person.greet();


	console.log("working with oop")
	var employee = new Object()      //<-- instantiation from Object
	var books = new Array("C++","Perl","Java")
	var day = new Date("Augus 15, 1947")

	console.log(employee)
	console.log(books)
	console.log(day)

	var book = new Object()
	book.subject = "Perl"
	book.author = "Mustafa"
	console.log(book)
	console.log(book.subject)
	console.log(book.author)
	*/

	//Another way to create object with user-defined name_function
	function addPrice(amount){
	  //this.price = amount
	  with(this){
	    price = amount
	  }
	}

	function book(title, author){
	  this.title = title
	  this.author = author
	  this.price = 0   //used when we use with keyword above.
	  this.addPrice = addPrice
	}

	var myBook = new book("Perl","Mustafa")
	myBook.addPrice(100)

	//console.log(myBook)
	console.log(myBook.title)
	console.log(myBook.author)
	console.log(myBook.price)


# In JavaScript, the (this) keyword refers to an object.
	- In an object method, this refers to the object.
	const person = {
		firstName: "John",
		lastName : "Doe",
		id       : 5566,
		fullName : function() {
		    return this.firstName + " " + this.lastName;
		}
	};

	- Alone, this refers to the global object.
		let x = this;
	
	- In a function, this refers to the global object.
		function myFunction() {
  			return this;
		}
	
	- In strict mode when used alone, this also refers to the global object
		"use strict";
		let x = this;

	- In a function, in strict mode, this is undefined.
		"use strict";
		function myFunction() {
			return this;
		}

	- In an event, this refers to the element that received the event.

# ES2015 (ES6): it's latest JS update.


# var vs let vs const in the JavaScript
	- const = constant --> read only, mean you are unable to change it's value after the declaration in the script


	- let <variable_name>
		1. let is block-scoped while var is function scoped.
		2. let does not allow to redeclare variables. var allows to redeclare variables.
		3. Hoisting does not occur in let. Hoisting occurs in var.


		1. Redeclaring a variable with var in a different scope or block changes the value of the outer variable too.
			
			var a = 5;
			console.log(a); // 5
			{
			    var a = 3;
			    console.log(a); // 3
			}
			console.log(a); // 3

		- Redeclaring a variable with let in a different scope or block treats that variable as a different variable. And the value of a variable outside does not change. For example,
			
			let a = 5;
			console.log(a); // 5
			{
			    let a = 3;
			    console.log(a); // 3
			}
			console.log(a); // 5

		1. When a variable declared with var is used in a loop, the value of that variable changes. For example
			
			var a = 2;
			for(var a = 0; a <= 3; a++) {
			    console.log('hello');
			}
			console.log(a); // 3


		- When a variable declared with let is used in a loop, the value of a variable does not change. For example,
			
			let a = 2;
			for(let a = 0; a <= 3; a++) {
			    console.log('hello');
			    console.log(a) //3
			}
			console.log(a); // 2

		
		2. A variable declared with var can be redeclared again. For example,
			
			var a = 5; // 5
			var a = 3; // 3

		- A variable declared with let cannot be redeclared within the same block or same scope. For example,
			
			let a = 5;
			let a = 3; // error


		3. Hoisting occurs in var

			x = 5
			console.log(x)
			var x

			- Hoisting does not occur in let.

			x = 3
			console.log(x)
			let x // error


# Anonymos function it's a function with out name located on the right of the code.
	
	const summary = function (usrName, usrAge, usrhasHobby){
		return(
		'Name is ' +
		usrName +
		', age is ' +
		usrAge +
		'and the user has hobbies: ' +
		userHasHobby
		);
	}

# another way to decalare function by using arrow => and remove function keyword
	const summary =  (usrName, usrAge, usrhasHobby) => {
		return(
		'Name is ' +
		usrName +
		', age is ' +
		usrAge +
		'and the user has hobbies: ' +
		userHasHobby
		);
	}


	more examples:

	const add = (a,b) => a + b;  // ommit return and curly braces
	const addOne = a => a + 1;   // we have one parameter
	const addRandome = () => 1 + 2; // no prarmeters



# arrays and array methods
	const hobbies =  ['Sports','Cooking']
	for (let hobby of hobbies){			// Using 'of' retrieve the element itself.
		console.log(hobby);
	}

	// Another example.
	dom = "BOOK"
	for(i in dom){						// Using 'in' retrieve index of the element.
	  console.log(dom[i])
	}

# There are a lot of functions can be used with array, one of them is map() it's working like updater and generate new array after update.

	console.log(hobbies.map(hobby => 'Hobby: ' + hobby));
	console.log(hobbies);


# arrays, objects and references types

	const hobbies = ['Sports', 'Cooking'];  <-- hobbies is reference to the memory place where values stored.

	hobbies.push('Programming')
	console.log(hobbies);


# spread and rest operators.
	
	- we can copy array using .slice()
		console.log(hobbies[hobbies])
	
	- another way  
		const copiedArray = [hobbies];
		console.log(copiedArray);		 <-- [['Sports','Cooking']]

		to avoid the result above we will use rest operator.
		const copiedArry = [...hobbies] <-- pull out all elements or properties and add it to the new array.
		const copiedPerson = {...person};


# another of rest operator (...) using, take a look on the example below:
	const toArray = (arg1,arg2,arg3) => {
		return [arg1,arg2,arg3];
	};
	console.log(toArray(1,2,3,4));  <-- result [1,2,3] it will not take the 4th element.

	- to resolve this issue we will use rest operator.

	const toArray = (...args) => {
		return args;
	}

# Destructuring:
	- take a look
		const printName = (personData) => {
			console.log(personData.name);
		}
	printName(person); <-- where person is an object

	* instead of using object.property we will use property only inside {}
		const printName = ({ name }) => {
			console.log(name);
		}
		printName(person);

	- take a look on the example below:
		const {name, age } = person;  <-- must be the same attributes in the object.
		console.log(name, age);  

	- to destruct elements from array
		const hobbies = ['Sports','Cooking'];
		const [hobby1, hobby2] = hobbies;
		console.log(hobby1, hobby2);

# callback
	- A callback is a function passed as an argument to another function

	- This technique allows a function to call another function

	- ex:
		function myDisplayer(some) {
	    console.log("=====myDisplayer=====")
	    console.log(some);
	  	}
	  
	  function myCalculator(num1, num2, myCallback) {
	    console.log("=====myCalculator=====")
	    let sum = num1 + num2;
	    myCallback(sum);
	  }
	  
	  myCalculator(5, 5, myDisplayer);


	- let's take a look on callback in deep 
		
		- callback mean pass function as argument to another function, as ex. below:
		
		function firstFunc(callback){
		  console.log("we are in the firstFunc")
		  callback('call secondFunc from firstFunc')
		}

		function secondFunc(p2){
		  console.log("secondFunc: ",p2)
		}
		
		firstFunc(secondFunc)	// pass secondFunc as argument to firstFunc

	- for more understand Async take a look on the function setTimeout() --> 
		
		const myTimeout = setTimeout(myGreeting, 5000);
		
		function myGreeting(){
			console.log("Hello Mustafa!")
		}

	- now let's do this in another way:
		setTimeout(() => {
			console.log('Timer is done')
		}, 5000);

		console.log('Hello!')
		console.log('Hi!') 

		- javascript will not stop or block running, it will execute the next lines

		- take a look on the example down:

		const fetchData = callback => {
			setTimeout(() => {
				callback('Done');
			},1500);
		};

		setTimeout(() => {
			console.log('Timer is done!');
			fetchData(text => {
				console.log(text);
			});
		}, 2000);


		console.log('Hello!');
		console.log('Hi!');

# Promises:
	- it's simply mean = I promise a resutl.

	- "Producing code" is code that can take some time

	- "Consuming code" is code that must wait for the result

	- A Promise is a JavaScript object that links producing code and consuming code

	- Promise object contains both the producing code and calls to the consuming code

	- Promise object can be:

	  state         result
     -------       --------
	Pending		    undefined
	Fulfilled       a result value
	Rejected  		an error object

	- You cannot access the Promise properties state and result.

	- You must use a Promise method to handle promises.

	- example:

	let myPromise = new Promise(function(myResolve, myReject) {
    setTimeout(function() { myResolve("I love You !!"); }, 3000);
  });
  
myPromise.then(function(value) {
console.log("value = ",value)
});


# # Async and promises

	- async makes a function return a Promise

	- await makes a function wait for a Promise
	- ex. 
	async function myDisplay() {
    	let myPromise = new Promise(function(resolve, reject) {
      		resolve("I love You !!");
    	});
    	console.log(await myPromise)
	  	}

	myDisplay();

	- The two arguments (resolve and reject) are pre-defined by JavaScript.

	- We will not create them, but call one of them when the executor function is ready.

	- very often we will not need a reject function.


# equal sign comarission: == inherently converts type and === does not convert type.

	- Double Equals (==) checks for value equality only. It inherently does type coercion. This means that before checking the values, it converts the types of the variables to match each other.

	- On the other hand, Triple Equals (===) does not perform type coercion. It will verify whether the variables being compared have both the same value AND the same type.


----------------------------------------------------------Section 3--------------------------------------------------------

# creating file and name it -> server.js or app.js --> this will be cosider root file

# let's name it as < app.js > for now.

# core modules in nodejs
	i. http
	ii. https
	iii. fs
	iv. path
	v. os

# let's take a look on how to import a module

	const http = require('http') <-- this will search for the module globally and it will find it coz nodejs already shipped with these modules.
	const http = require('./http') <-- this will search for the module in the same directory. (./) <- relative directory.

# after the step above, we can see all attributes and methods for the module (http), for exampl createServer();

	http.createServer(); --> 	if u hover over this function u can see it's taking function as parameter that should be executed
							 	for every incoming request.
							 	
							 	this function take 2 parameters, request and response.

								in this case we need to build new function as below,

									function rqListener(req, res){ // function could be any name. this is the request listener

								}

									http.createServer(rqListener)

								or we can use anonymous function instead of the function above and still do the same job.

									http.createServer(function (req, res){

									});

								or we can use arraw function instead as below

									http.createServer((req, res) => {
										console.log(req)
									})

								- The function above is create server method actually return a server, that's mean we need to assign this function to a variable.

									const server =  http.createServer((req, res) => {
									console.log(req)
									})

									server.listen() // one of the important methods, start process where node js will not immedatly exit our script.

									server.listen(3000) // the port where the server start listening and u can use any available port.

								- now u can execute the script above, although u will see nothing but u can use ur browser and put this url
									localhost:3000 -> u will see nothing as well on the page but check out the cmd log, u'll see alot of things.





# Event loop: Keeps on running as long as there are event listeners registered

# process will keep running till process exit, in the example below, if we send request through the web page it will be execute and exit.
	const server = http.createServer((req,res) => {
    	console.log(req)
    	process.exit()
	});


# btw if u take a look on the output log when u send a request, the output contain a lot of attributes that can be used to retrieve useful information.
	req.url or req.headers ...etc.
	
	const server = http.createServer((req,res) => {
    	console.log(req.url, req.method, req.headers)
    	process.exit()
	});

# till this point there's no response to the request that had been submitted, let's add some response.
	res.setHeader('Content-Type', 'text/html')  //Content-Type is a default header, text/html is the type of the code.

	- at this point we set the header and we tell send html code but we didn't send anything yet.
	- we will wirte html code as below:
		res.write('<html>')
		res.write('<head><title>My First Page</title></head>')
		res.write('<body><h1>Hello from my Node.js Server</h1></body>')
		res.write('</html>')

	- after this all what we need to send back the response by using:
		res.end() // This will tell nodejs to send back the response.

	- we can control the way that server is response to different url request.
		if(url === '/'){
			res.write('<html>')
			res.write('<head><title>Enter Message</title></head>')
			res.write('<body><form action="/message" method="POST"><input type="text"><button type="submit">Send</button></form></body>')
			res.write('</html>')
			return res.end()
		}

	- in the ex. above it will send post request to /message
	- u can see also we used return res.end() in order to get out of the anonymous function and not continue to the next one.

	- we can add logic to evaluate both url path as well the method type used.
		if (url === '/message' && method === 'POST')

	- let's add more functionality to the response, so when user hit submit --> back to the root and create file to save message in.

	- in this case we need to use file system (fs) which is one of the core modules, to write to a file and as we know we can use require to use such module:
		> require(fs)

	- to write to file and back to the root
		fs.writeFileSync('message.txt', 'DUMMY');
		res.statusCode = 302;
		res.setHeader('Location', '/');
		return res.end();

	- now if we need to pass the information that submitted when we click on submit there's no method like req.data !

	- there's another way that javascript and nodejs use is called streams and buffers.

	- streams: are objects that let you read data from a source or write data to a destination in continuous fashion. In Node.js,
	  	
	  	* there are four types of streams:

			Readable − Stream which is used for read operation.

			Writable − Stream which is used for write operation.

			Duplex − Stream which can be used for both read and write operation.

			Transform − A type of duplex stream where the output is computed based on input.

		* types of <event> that can deal with:

			data − This event is fired when there is data is available to read.

			end − This event is fired when there is no more data to read.

			error − This event is fired when there is any error receiving or writing data.

			finish − This event is fired when all the data has been flushed to underlying system.

	- now to capture data from submit we will registering event listener.
		req.on()
		 -> on is an event listener
		 -> it's method allows us to listen to certain event.
		 -> it's take 2 parameters 
		 	1. event
		 	2. function should be executed when event occur
		req.on('data') --> data is the event.

	- we will create function like the server above that will keep listen -> event listener.
		req.on('data', (chunk) => {

		})

	- as we know we are dealing with chunks of data in the stream and then we need to collect all these chunks together in an array.

		const body = []
		req.on('data', (chunk) => {							//register event listener -> 'data'
			console.log(chunk) // to see what in side chunk
			body.push(chunk);
		})
		req.on('end')  										//register event listener -> 'end'

		the event listener 'end' -> will be fired once it's done parsing the incoming requests data or the incoming requests in general

	- now the question is what after we store all chunks in the array?
		* to answer this question we need to buffer them :)


# Callback: is simply a function passed as an argument to another function which will then use it (call it back)

# event-driven programming:
											  			  Event handlers
	event emitters --> event event event --> event loop  --> { 		}

# callback vs events: the difference lies in the fact that callback functions are called when an asynchronous function returns its result, whereas event handling works on the observer pattern.

# to create events
	1. import events module
	2. create an eventEmitter object
	3. bind event and event handler
	4. fire an event.

# let's back to our script, after 'end' event fired that's mean we got all chuncks in the list -> body, we need to do 
	1. create buffer object -> to work as bus stop where all should be stay there.
	2. concatenate chuncks together

# take a look on the code below:
	      req.on('end', () => {
            const parsedBody = Buffer.concat(body).toString();
            console.log(parsedBody)
          }); 
          --> the result for the code above will be --> message=Hello+Mustafa

# be carefull if we have someting waiting incoming data from the listener, we need to move it into the listener block

# Nodejs look like it have registery for events as well listener for these events.

# event loop will only handle callbacks that contain fast finish code.

# as we know nodejs use single process single thread. 

# the metholodgy above will not help us with long work with high volume files.

# instead our file system and a couple of other long taking operations are sent to a < worker pool >

# worker pool: is responsible for all heavy lifting, it spin up and managed by nodjs automatically.

# workers are totally detach from ur javascript code, from ur request and the event loop, it run in different threads. it can use multiple threads and run closely to ur o.s.

# once the worker is done, for ex. read a file, it will trigger the callback for that read file operation, since the event loop is responsible for the events and the callbacks, this will end the end up in the event loop.

# event loop use setTimeout and setInterval, take a look on the sequence below:
	
	Timers
	------------------
	Execute setTimeout,
	setInterval Callbacks
	  |
	  v
	Pending Callbacks
	------------------
	Execute I/O - related			I/O -> Input/Output like Disk, Network ..etc
	Callbacks that were deferred
	  |
	  v
	Poll
	------------------
	Retrieve new I/O events,
	execute their callbacks
	  |
	  v
	Check
	------------------
	Execute setImmediate()
	callback
	  |
	  v
	Close Callbacks
	------------------
	Execute all 'close' event
	callbacks
	  |
	  v
	process.exit


# we can use export to export module in different way.
	- module.exports = requestHandler;				--> to access required func, we need to use routes.handler.
	- module.exports = {handler: requestHandler,
						somekey: somefunction}    
	- module.exports.handler = requestHandler;
	- exports.handler = requestHandler;

---------------------------------------------------------Section-4--------------------------------------------------------

# to initilize nodejs project use:
	> npm init

# let's modify the scripts part --> "scripts" by adding ',' and write below script
	"start" : "node app.js"  --> it's the same command that we use to run our app, now to run our app again.
	> npm <script>
	> npm start

# u can add more scripts, without using special name, just be sure to wrap the name in double qutations and doesn't contain any blanks.

# to start special script
	> npm run <my-script-name>

# to install third-party package and u need it only for dev purpose
	> npm install <package-name> --save-dev
	> npm install nodemon --save-dec   --> this package use to develope code without stop server and re-run it

	- using the command above will give u node-modules folder and package-lock.json file and it will modify our package.json by adding new key --> "devDependenceies"

	- if you see in the version -->  ~1.0.2 it means to install version 1.0.2 or the latest patch version such as 1.0.4. If you see ^1.0.2 it means to install version 1.0.2 or the latest minor or patch version such as 1.1.0.

	- package-lock.json --> store the current versino of package that you installed (the version at installation time)

	- to use the utility package like nodemon do:
		i. change the command in the script part in package.json to be
			"start": "nodemon app.js"
		ii. > npm start

# There are 3 types of errors:
	- Syntax Errors	 --> sometime it's easy to find it and sometime need alot of time to find it.
	- Runtime Errors --> for example ERR_HTTP_HEADERS_SENT where we set header after send response.
	- Logical Errors --> it's not something that raise error, but u can see different behavior than that expected.
	  
	  * to deal with logical error we can use vs code debugger
	    --> select your entry pint like app.js --> in the menue select debug --> start debugging --> select environment: nodejs 
	    --> now go to debug console --> u need to set break point. 
	  * the app will run till the breakpoint and stop.
	  * u can just hover over the variables and see what actually took.
	  * for more detaile u can go to view --> debug. it will give u more details, on the left bar.
	  * u can also manage breakpoint from left bar as well, by check or uncheck them.
	  * to see how process go in ur code check on the left bar, call stack.
	  * becarful when using -> step over, step into (block), step out(block)
	  * for any future block execution, just put breakpoint so u can see when it will be reach out to this point.
	  * you can test any lind code in the debug console and see how it will behave.

	  * debugger by default don't restart code after modifing, so it's nice to use nodemon with debugger.
	  * to do so --> go to menu --> debug --> add configuration --> lunch.json file -->
	  * add the lines below in the configurations value
	  	"restart": true,
	  	"runtimeExecutable": "nodemon"
	  * we can also as debugger to start with specific file instead of select file <app.js> each time and start debugging.
	  * we can change which console to use by adding the line code below to the configurations key
	  	"console": "intgratedTerminal"  -> this method needed when using nodemon
	  * as well if u wanna to use it in this way all what u need is install nodemon on global
	  * if using nodemone use ctrl+c to stop it in the console.
	  * for more details about debugging with nodejs
	  	https://code.visualstudio.com/docs/nodejs/nodejs-debugging

	  * from left panal --> VARIABLES --> if u double click on any value u can just simpy modified it for testing purposes.


---------------------------------------------------------Section-5--------------------------------------------------------

# this section is how to use Express.js
	i. what is express.
	ii. using middleware
	iii. working with requests and responses
	iv. routing
	v. returning HTML Pages(Files)

# Framwork: Helper functions, tools and rules that help you build your application.

# first thing we need to install express 
	> npm install  --save express   -> production dependency

# what we will do is import express and do the steps below:
	const express = require('express')
	const app = express() 					<-- app will handle the incoming request
	const server = http.createServer(app);  <-- app here will do nothing because we didn't define anything yet

# middleware: incoming request is automatically funneled threough a bunch of functions by expressjs.
	Middleware -->  (req,res,next) => {...}

# to add any functionality u will add new middleware function, to do so u need to use function --> use([array of requests])
	
	- ex. app.use((req,res,next) => {

	})
	- next paramter, will let you travel to the next middle ware function

# to send respnse back we will only need to use res.send() <-- new utility function in the express.
	ex. res.send('<h1>Hello from Express!</h1>')

# instead of creating server and listen to a port we can do both to gether
	app.listen(3000)

# to use redirect 
	res.redirect(path) --> res.redirect('/')

# to parse body we need to register parser, but first we need to install body-parser
	npm install --save body-parser

# take a look on the code below:
	app.use('/',(req,res,next)=>{
	    console.log("This is always runs!")
	    next()
	})
	- this part will always be called
	- if we need to limit this only for get request.
	- we need to do some change instead of using the app.use (.use for all kind of request)we will
		i. app.get 
		ii. app.post
		iii. app.put
		iv. app.delete

# it's really good to split our routes over multiple files, we can name as <routes> or anything else.
	- move stuff from app.js --> entry point to routes files.

# to write 404 page to response to wrong request.
	app.use((req,res,next)=>{
	    res.status(404).send('<h1>Page not found</h1>')
	})

# we can use filter mechanism by adding common starting segment
	app.use('/admin',adminRoutes) --> so we don't need to add the admin segment to each routs in admin.js


---------------------------------------------------------Section-7--------------------------------------------------------

# MVC stand for - Model - Views - Controllers: it's used for sparation of concerns

		Models 						Views 							   Controllers
	--------------				-------------						----------------
- Response your data in       - What the users sees         	 - connection your models
  your code 													   and your views
- working with your data      - Decoupled from your 			 - contains the "in-between"
  (e.g. save, fetch)            application code                   logic


# the idea of Controllers folder can be describe in the steps below:
	- the code below from routes directory --> admin.js
	router.get('/add-product',(req,res,next) => {
	    console.log("we are in the middleware!");
	    res.send('<form action="/admin/add-product" method="POST"><input type="text" name="title"><button type="submit">Add Production</button></form>');
	});

	- create new directory <controllers> 
	- create new file for example <products.js> that will include all logics related to products.
	- move the anonymous fx from the router.get above and assign to any name u like.
		exports.getAddProduct = (req,res,next) => {
	    console.log("we are in the middleware!");
	    res.send('<form action="/admin/add-product" method="POST"><input type="text" name="title"><button type="submit">Add Production</button></form>');
	}
	- import ur controllers 
		const productsController = require('../controllers/products')

	- now the function in the admin.js will be like
		router.get('/add-product', productsController.getAddproduct)

---------------------------------------------------------Section-9--------------------------------------------------------

---------------------------------------------------------Section-12-------------------------------------------------------

# it must go back to the mongoDB intro to start with this part.

# u don't need to install mongoDB, instead u need to spin one on the cloud name --> Atlas.
	- use all default settings and be sure there's free tier before submit.

# need to install mongoDB driver using
	> npm install --save mongodb



---------------------------------------------------------Section-26-------------------------------------------------------